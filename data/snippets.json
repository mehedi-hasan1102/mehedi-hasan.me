[
  {
    "title": "Debounce Function",
    "description": "Prevents a function from being called too frequently.",
    "language": "JavaScript",
    "code": "function debounce(fn, delay = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  };\n}"
  },
  {
    "title": "Throttle Function",
    "description": "Limits how often a function can run over time.",
    "language": "JavaScript",
    "code": "function throttle(fn, delay = 300) {\n  let lastCall = 0;\n  return (...args) => {\n    const now = Date.now();\n    if (now - lastCall >= delay) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}"
  },
  {
    "title": "Deep Clone (JSON)",
    "description": "Quick deep clone for plain objects (no functions).",
    "language": "JavaScript",
    "code": "function deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}"
  },
  {
    "title": "Fetch Wrapper",
    "description": "Standardized fetch wrapper with error handling.",
    "language": "JavaScript",
    "code": "async function fetchJson(url, options = {}) {\n  const res = await fetch(url, options);\n  if (!res.ok) throw new Error('Network response was not ok');\n  return res.json();\n}"
  },
  {
    "title": "Format Date",
    "description": "Format date into YYYY-MM-DD.",
    "language": "JavaScript",
    "code": "function formatDate(date) {\n  const d = new Date(date);\n  return d.toISOString().split('T')[0];\n}"
  },
  {
    "title": "Create Range Array",
    "description": "Generate a range of numbers like Python range().",
    "language": "JavaScript",
    "code": "function range(start, end) {\n  return Array.from({ length: end - start + 1 }, (_, i) => start + i);\n}"
  },
  {
    "title": "Safe Access (Optional Chaining)",
    "description": "Safely access nested object values without errors.",
    "language": "JavaScript",
    "code": "const value = obj?.a?.b?.c ?? 'default';"
  },
  {
    "title": "React useDebounce Hook",
    "description": "Debounce any value in React (good for search input).",
    "language": "TypeScript",
    "code": "import { useEffect, useState } from 'react';\n\nfunction useDebounce<T>(value: T, delay = 300): T {\n  const [debounced, setDebounced] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debounced;\n}\n\nexport default useDebounce;"
  },
  {
    "title": "React useLocalStorage Hook",
    "description": "Persist state to localStorage.",
    "language": "TypeScript",
    "code": "import { useEffect, useState } from 'react';\n\nfunction useLocalStorage<T>(key: string, initialValue: T) {\n  const [value, setValue] = useState<T>(() => {\n    if (typeof window === 'undefined') return initialValue;\n    const stored = window.localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initialValue;\n  });\n\n  useEffect(() => {\n    window.localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue] as const;\n}\n\nexport default useLocalStorage;"
  },
  {
    "title": "Next.js fetch with revalidation",
    "description": "Fetch data with ISR using Next.js App Router.",
    "language": "TypeScript",
    "code": "export async function fetchWithRevalidate(url: string, revalidateSeconds = 60) {\n  const res = await fetch(url, { next: { revalidate: revalidateSeconds } });\n  if (!res.ok) throw new Error('Failed to fetch');\n  return res.json();\n}"
  },
  {
    "title": "React useOnClickOutside Hook",
    "description": "Detect clicks outside a ref element (for modals/dropdowns).",
    "language": "TypeScript",
    "code": "import { useEffect } from 'react';\n\nfunction useOnClickOutside(ref: React.RefObject<HTMLElement>, handler: () => void) {\n  useEffect(() => {\n    const listener = (event: MouseEvent) => {\n      if (!ref.current || ref.current.contains(event.target as Node)) return;\n      handler();\n    };\n\n    document.addEventListener('mousedown', listener);\n    return () => document.removeEventListener('mousedown', listener);\n  }, [ref, handler]);\n}\n\nexport default useOnClickOutside;"
  },
  {
    "title": "Accessible Focus Trap",
    "description": "Simple focus trap for modals.",
    "language": "JavaScript",
    "code": "function trapFocus(modal) {\n  const focusable = modal.querySelectorAll('a, button, input, textarea, select, [tabindex]');\n  const first = focusable[0];\n  const last = focusable[focusable.length - 1];\n\n  modal.addEventListener('keydown', (e) => {\n    if (e.key !== 'Tab') return;\n\n    if (e.shiftKey && document.activeElement === first) {\n      e.preventDefault();\n      last.focus();\n    } else if (!e.shiftKey && document.activeElement === last) {\n      e.preventDefault();\n      first.focus();\n    }\n  });\n}"
  },
  {
    "title": "Tailwind Responsive Container",
    "description": "Reusable container for consistent layout width.",
    "language": "CSS",
    "code": ".container {\n  width: 100%;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 1rem;\n}\n\n@media (min-width: 768px) {\n  .container {\n    padding: 0 2rem;\n  }\n}"
  },
  {
    "title": "HTTP Retry Logic",
    "description": "Retry fetch requests automatically on failure.",
    "language": "JavaScript",
    "code": "async function fetchWithRetry(url, options = {}, retries = 3, backoff = 300) {\n  try {\n    const res = await fetch(url, options);\n    if (!res.ok) throw new Error('Fetch failed');\n    return await res.json();\n  } catch (err) {\n    if (retries <= 0) throw err;\n    await new Promise((r) => setTimeout(r, backoff));\n    return fetchWithRetry(url, options, retries - 1, backoff * 2);\n  }\n}"
  },
  {
    "title": "URL Query Parser",
    "description": "Parse query params into object.",
    "language": "JavaScript",
    "code": "function parseQuery(search) {\n  return Object.fromEntries(new URLSearchParams(search));\n}\n\n// usage: parseQuery(window.location.search)"
  }
]
